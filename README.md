# 设计模式

GitHub:https://github.com/say-code/DesignPattern

## 代码环境

jdk 1.8

JUnit 4.13.1

dom4j 2.1.3 (在lib文件夹中，可直接导入项目)

## 常用面向对象设计原则

- 单一职责原则

  一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中

  [代码位置](./src/main/principle/singleResponsibility)

- 开闭原则

  软件实体应该对扩展开放，对修改关闭

  [代码位置](./src/main/principle/openClosed)

- 里氏代换原则

  所有引用基类的地方必须能透明地使用其子类对象

  [代码位置](./src/main/principle/richterSubstitution)

- 依赖倒转原则

  高层模块不应该依赖底层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

  [代码位置](./src/main/principle/dependenceInversion)	

- 接口隔离原则

  客户端不应该依赖那些不需要的接口

  [代码位置](./src/main/principle/interfaceSegregation)	

- 合成复用原则

  优先使用对象组合，而不是继承来达到复用的目的

  [代码位置](./src/main/principle/compositeReuse)	

## 工厂模式

​	在工厂方法模式中，工厂方法用来创建客户所需要的铲平，同时还向哭护颖仓了那种具体产品类将被实例化这一细节。工厂方法模式的核心是抽象工厂类Factory，各种具体工厂类集成抽象工厂类并实现在抽象工厂类中定义的工厂方法，从而使得客户只需要关心抽象产品和抽象工厂，完全不用理会返回的是哪一种具体产品，也不用关心它是如何被具体工厂创建的。在系统中加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样，系统的可扩展性也就变得非常好，符合开闭原则。但是在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，难免会增加系统类的个数，增加系统的开销。

- 工厂方法模式实例之日志记录器 [代码位置](./src/main/factoryMethod/example)
- 简单计算器 [代码位置](./src/main/factoryMethod/simpleCalculator)
- 图片读取器 [代码位置](./src/main/factoryMethod/ImgRead)

## 建造者模式

​	建造者模式强调将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式描述如何一步一步地创建一个复杂地对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。

